/**
 * @file motion.c
 * @brief Motion Controller
 *
 * Part of OpenGlow-CNC
 *
 * @copyright Copyright (c) 2018 Scott Wiederhold <s.e.wiederhold@gmail.com>
 *
  * Adapted from Grbl
 * @copyright Copyright (c) 2011-2016 Sungeun K. Jeon for Gnea Research LLC
 * @copyright Copyright (c) 2009-2011 Simen Svale Skogsrud
 *
 * SPDX-License-Identifier:    GPL-3.0-or-later
 *
 * @defgroup motion Motion Planning and Control
 *
 * Motion Planning and Control
 *
 * @code
 *                   BLOCK VELOCITY PROFILE DEFINITION
 *          __________________________
 *         /|                        |\     _________________         ^
 *        / |                        | \   /|               |\        |
 *       /  |                        |  \ / |               | \       s
 *      /   |                        |   |  |               |  \      p
 *     /    |                        |   |  |               |   \     e
 *    +-----+------------------------+---+--+---------------+----+    e
 *    |               BLOCK 1            ^      BLOCK 2          |    d
 *                                       |
 *                  time ----->      EXAMPLE: Block 2 entry speed is at maximum junction velocity
 *
 * @endcode
 *
 * The motion block buffer is planned assuming constant acceleration velocity profiles and are
 * continuously joined at block junctions as shown. However, the motion only actively computes
 * the block entry speeds for an optimal velocity plan, but does not compute the block internal
 * velocity profiles. These velocity profiles are computed ad-hoc as they are executed by the
 * stepper algorithm and consists of only 7 possible types of profiles: cruise-only, cruise-
 * deceleration, acceleration-cruise, acceleration-only, deceleration-only, full-trapezoid, and
 * triangle(no cruise).
 *
 * @code
 *                            SEGMENT VELOCITY PROFILE DEFINITION
 *
 *                                        maximum_speed (< nominal_speed) ->  +
 *                    +--------+ <- maximum_speed (= nominal_speed)          /|\
 *                   /          \                                           / | \
 * current_speed -> +            \                                         /  |  + <- exit_speed
 *                  |             + <- exit_speed                         /   |  |
 *                  +-------------+                     current_speed -> +----+--+
 *                   time -->  ^  ^                                           ^  ^
 *                             |  |                                           |  |
 *                decelerate_after(in mm)                             decelerate_after(in mm)
 *                    ^           ^                                           ^  ^
 *                    |           |                                           |  |
 *                accelerate_until(in mm)                             accelerate_until(in mm)
 *
 * @endcode
 * The step segment buffer computes the executing block velocity profile and tracks the critical
 * parameters for the stepper algorithm to accurately trace the profile. These critical parameters
 * are shown and defined in the above illustration.
 *
 * The segment buffer is an intermediary buffer interface between the execution of steps
 * by the stepper algorithm and the velocity profiles generated by the motion. The stepper
 * algorithm only executes steps within the segment buffer and is filled by segment_prep_buffer().
 * Steps are "checked-out" from the first block in the motion buffer. This keeps the
 * step execution and planning optimization processes atomic and protected from each other.
 * @note Computation units are in steps, millimeters, and minutes.

 * @{
 * @defgroup motion_init Initialization
 *
 * Initialization of the planning and motion control systems.
 *
 * @{
 */

#include <semaphore.h>
#include "../openglow-cnc.h"

/**
 * @brief Motion FSM state mutex
 * Used to ensure atomic writes to the Motion FSM state variable
 */
static sem_t mot_state_mutex;

// Static function declarations
static void _motion_fsm_handler();


/**
 * @brief System FSM to Motion FSM Mapping
 *
 * Describes which Motion FSM states are valid for System FSM states.
 */
static const sys_to_sub_map_t mot_sys_sub[] = {
        {SYS_STATE_INIT, MOT_STATE_INIT},
        {SYS_STATE_SLEEP, MOT_STATE_IDLE},
        {SYS_STATE_IDLE, MOT_STATE_IDLE},
        {SYS_STATE_HOMING, MOT_STATE_RUN},
        {SYS_STATE_RUN, MOT_STATE_RUN},
        {SYS_STATE_HOLD, MOT_STATE_HOLD},
        {SYS_STATE_ALARM, MOT_STATE_ALARM},
        {SYS_STATE_FAULT, MOT_STATE_FAULT},
};

/**
 * @brief FSM State Map registration structure
 *
 * Used to register the System FSM to Motion FSM Mapping with the System FSM
 */
static const sub_state_map_t mot_state_map = {
        .num = sizeof(mot_sys_sub) / sizeof(sys_to_sub_map_t),
        .maps = &mot_sys_sub[0],
        .fsm_handler = _motion_fsm_handler,
};

/**
 * @brief Motion FSM State
 *
 * Current state of the Motion Finite State Machine
 */
static volatile enum mot_fsm_states mot_state = MOT_STATE_UNINITIALIZED;

/**
 * @brief System FSM Message handler
 */
void _motion_fsm_handler() {
    uint8_t new_state = mot_state;
    if ((sys_req_state == SYS_STATE_RUN) && (mot_state == MOT_STATE_IDLE)) new_state = MOT_STATE_RUN;
    else if ((sys_req_state == SYS_STATE_IDLE) && (mot_state == MOT_STATE_RUN)) new_state = MOT_STATE_IDLE;

    if (new_state != mot_state) {
        mot_state = new_state;
        fsm_update(FSM_MOTION, mot_state);
    }
}

/**
 * Initialize Motion system
 * @return 0 on success, negative on error.
 */
ssize_t motion_init() {
    ssize_t ret = 0;

    gc_init();
    plan_reset();
    stepgen_clear();

    sem_init(&mot_state_mutex, 0, 1);

    fsm_register(FSM_MOTION, mot_state_map);
    motion_state_update(MOT_STATE_IDLE);

    return ret;
}

/**
 * @brief Reset Motion system
 */
void motion_reset() {
    plan_reset();
}

/**
 * @brief Update Motion system state
 * @param state New state
 */
void motion_state_update(enum mot_fsm_states state) {
    sem_wait(&mot_state_mutex);
    if (mot_state != state) {
        mot_state = state;
        fsm_update(FSM_MOTION, mot_state);
    }
    sem_post(&mot_state_mutex);
}

/** @} */
/** @} */
